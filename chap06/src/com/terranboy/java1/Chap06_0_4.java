package com.terranboy.java1;

public class Chap06_0_4 {

	public static void main(String[] args) {
		//객체 배열 (참조변수의 배열 / 객체의 주소가 담김)
		//많은 수의 객체를 다뤄야할 때 배열로 다루면 편리할 것이다.
		//객체 역시 배열로 다루는 것이 가능하며, 이를 '객체 배열'이라 부름.
		//객체 배열 안에 객체가 저장되는 것은 아니고, 객체의 주소가 저장된다. (2차원 배열이 저장되는 방식하고 같네?)
		//이러한 것들을 생각해보면 객체배열은 참조변수들을 하나로 묶은 참조변수 배열인 셈이다.
		
		//Tv tv1, tv2, tv3; ----> Tv[] tvArr = new Tv[3];  길이가 3인 Tv타입의 참조변수 배열
		
		// 객체 배열을 생성하는 것은, 그저 객체를 다루기 위한 참조변수들이 만들어진 것일 뿐, '아.직.객.체.가.저.장.되.지.않.았.다'
		
		// 참조변수 배열(객체 배열)을 생성하고 실제 객체를 생성하는 방법들을 보자.
		// 첫번째(일일이)
		// tvArr[0] = new Tv();
		// tvArr[1] = new Tv();
		// tvArr[2] = new Tv();
		//------------------------------
		// 두번째(배열 초기화 블럭)
		// Tv[] tvArr = {new Tv(), new Tv(), new Tv() };
		//------------------------------
		// 세번째(for문)
		// Tv[] tvArr = new Tv[100];
		// for(int i=0; i<tvArr.length;i++){
		//      tvArr[i] = new Tv();
		// }
		//------------------------------
		
		//모든 배열이 그렇듯 객체 배열도 같은 타입의 객체만 저장이 가능하다.
		//여러 종류의 객체를 하나의 배열에 저장하는 방법은 없을까?
		//----> 갓 '다형성'을 배우고나면 하나의 배열로 여러 종류의 객체를 다룰 수 있게 된다.
		
		Tv[] tvArr = new Tv[3];
		
		for(int i=0; i< tvArr.length; i++) {
			tvArr[i] = new Tv();
			tvArr[i].channel = i+10;     // 각각 채널 10, 11, 12 넣기
		}
		
		for(int i=0; i< tvArr.length; i++) {
			tvArr[i].channelUp();        // 채널업 메서드 호출을 통해 각각 채널이 11, 12, 13이 됨.
			System.out.printf("tvArr[%d].channel=%d%n", i, tvArr[i].channel);
		}
		
		
		// 클래스의 또다른 정의
		//-------------------------------------------------------------------------------------
		// 1) 데이터와 함수의 결합
		// 위에서 배운 클래스(클래스는 객체를 생성하기 위한 틀이며 속성+기능이다.)는 객체지향이론의 관점에서 내린 정의고
		// 이번엔 프로그래밍적 관점에서 클래스의 정의와 의미에 대해 살펴보자.
		// 객체지향개념 이전에 데이터는 같은 종류의 데이터끼리 따로 다루어져 왔는데, 사실 함수는 데이터를 가지고 작업을 하기 때문에 연관이 깊다. 
		// 그래서 자바같은 객체지향 언어에서는 변수(데이터)와 함수를 하나의 클래스에 정의해 서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있게 했다.
		// (시간은 시간, 분은 분, 초는 초 이렇게 같은 종류끼리 다루는 게 이전 데이터 처리 개념이라면 자바는 의미에 맞게 시분초로 갖다 쓰겠다는 것)
		// 
		// 2) 사용자정의 타입(user-defined type) 
		// 기본 자료형 외에 프로그래머가 서로 관련된 변수들을 묶어 하나의 타입으로 새로 추가하는 거.
		// 기본형 갯수는 정해져있지만 참조형 갯수가 정해져 있지 않은 이유는 이렇게 프로그래머가 새로운 타입을 추가할 수 있어서야~!
		
		// 기존 방식(시분초를 다루려면 다 따로따로..!!)
		// int[] hour = new int[3]; 
		// int[] minute = new int[3]; 
		// int[] second = new int[3]; 
	
		// 클래스방식(유의미하다!)
		// class Time {
		//      int hour;
		//      int minute;
		//      float second;
		// }
		
		//근데 잘 보면 시간에는 제약조건이 있다.
		// 1) 0<=시분초
		// 2) 0<=시<=23, 0<=분,초<=59
		//객체지향언어가 아닌 언어에선 이런 추가적인 조건들 반영하기가 쉽지가 않다.
		//객체지향언어에서는 제어자와 메서드를 이용해 이런 조건들을 코드에 쉽게 반영 가능!
		//제어자를 이용해 변수의 값을 직접 변경 못하게 하고 메서드를 통해 값을 변경하도록 작성.
		//값을 변경할 땐 지정된 값의 유효성을 조건문으로 점검한 다음 유효한 값일 경우에만 변경케함.
		//이 외에도 시간의 차를 구하는 메서드와 같이 시간과 관련된 메서드를 추가로 정의해 Time클래스를 향상시켜 보는 것도 좋은 공부가 될 것!
		
		//	public class Time{
		//		private int hour;
		//		private int minute;
		//		private float second;
		//			
		//		public int getHour() {return hour;}
		//		public int getMinute() {return minute;}
		//		public float getSecond() {return second;}
		//			
		//		public void setHour(int h) {
		//			if(h<0 || h>23) return;
		//			hour = h;
		//		}
		//			
		//		public void setMinute(int m) {
		//			if(m<0 || m>59) return;
		//			minute = m;
		//		}
		//			
		//		public void setSecond(float s) {
		//			if(s<0.0f || s >59.99f) return;
		//			second = s;
		//		}
		//	}
		
		
	}

}
