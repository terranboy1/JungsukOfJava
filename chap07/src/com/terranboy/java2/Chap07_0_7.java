package com.terranboy.java2;

public class Chap07_0_7 {

	public static void main(String[] args) {
		/*
		super() - 조상클래스의 생성자
		this()와 마찬가지로 super() 역시 생성자다.
		차이점은 this()는 같은 클래스의 다른 생성자를 호출하는 데 사용되지만
		super()는 조상 클래스의 생성자를 호출하는 데 사용된다.
		
		자손 클래스의 인스턴스를 생성하면 자손의 멤버와 조상의 멤버가 합쳐진 하나의 인스턴스가 생성된다.
		그래서 자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용할 수 있는 것이다.
		이 때 조상 클래스 멤버의 초기화 작업이 수행되어야 하기 때문에 자손 클래스의 생성자에서
		조상클래스의 생성자가 호출되어어야 한다.(그치, 조상 멤버가 초기화되는 게 먼저지.)
		그 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용하려면 조상 멤버들이 먼저 초기화되어 있어야 하기 때문이지. 
		이와 같은 조상 클래스 생성자의 호출은 클래스의 상속관계를 거슬러 올라가면서 계속 반복됨.
		마지막으로 Object클래스의 생성자인 Object()까지 가서야 비로소 끝이 난다네.
		그래서 Object클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 '자신의 다른 생성자 또는 조상의 생성자를 호출'해야 한다네.
		그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 자동으로 추가할 것이라네.
		
		그리고 인스턴스를 생성할 때는 클래스를 선택하는 것만큼 생성자 선택도 중요하다!!!!!
		1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
		2. 생성자 - 선택한 클래스의 어떤 생성자를 이용해 인스턴스를 생성할 것인가?
		*/
		
	}
}

class Point2 {
	int x, y;
	
	//Point2 클래스의 기본생성자를 주석처리하면 어떤 일이 벌어질지 생각해보자.
	Point2(){
	}
	
	Point2(int x, int y){
		this.x = x;
		this.y = y;
	}
	
	String getLocation() {
		return "x :" + x + ", y:" + y;
	}
}

class Point3D2 extends Point2 {
	int z;
	
	Point3D2(int x, int y, int z){
		//super(); -- 컴파일러가 생성
		//super(x, y); -- 개발자가 직접 입력하면 컴파일러가 super(); 생성 안함.
		//상속받은 클래스의 생성자에서는 부모의 생성자를 호출해야한다. 따로 호출하지 않으면 컴파일러가 자동적으로 super();를 입력해 부모클래스의 기본생성자를 호출한다.
		//생성자가 정의되어있지 않은 경우에만 추가하지 개발자가 직접 입력하면 컴파일러가 따로 추가하지 않는다.
		//이처럼 조상 클래스의 멤버변수는 조상의 생성자에 의해 초기화되도록 하게 만든 것!
		this.x = x;
		this.y = y;
		this.z = z;
	}
	
	String getLocation() {
		return super.getLocation() + ", z :" + z;
	}
}
